import 'dart:async';
import 'dart:io';

import 'package:glob/glob.dart';
import 'package:path/path.dart' as p;

import 'utils.dart';

Future<String> runBuildRunner(
    String tempDir, String targetDir, String config, bool release) async {
  if (Platform.isWindows) {
    printError('Currently uses Unix shell commands `cp` and `mkdir`.'
        ' Will likely fail on Windows.'
        ' See https://github.com/kevmoo/peanut.dart/issues/11');
  }

  var args = [
    'run',
    'build_runner',
    'build',
    '--output',
    tempDir,
    release ? '--release' : '--no-release'
  ];

  if (config != null) {
    args.addAll(['--config', config]);
  }

  await runProcess(pubPath, args, workingDirectory: p.current);

  // Verify `$tempDir/$targetDir` exists
  var contentPath = p.join(tempDir, targetDir);
  if (!FileSystemEntity.isDirectorySync(contentPath)) {
    throw new StateError('Expected directory `$contentPath` was not created.');
  }

  var packagesSymlinkPath = p.join(contentPath, 'packages');
  switch (FileSystemEntity.typeSync(packagesSymlinkPath, followLinks: false)) {
    case FileSystemEntityType.NOT_FOUND:
      // no-op –nothing to do
      break;
    case FileSystemEntityType.LINK:
      var packagesLink = new Link(packagesSymlinkPath);
      assert(packagesLink.existsSync());
      var packagesDirPath = packagesLink.targetSync();
      assert(p.isRelative(packagesDirPath));
      packagesDirPath = p.normalize(p.join(contentPath, packagesDirPath));
      assert(FileSystemEntity.isDirectorySync(packagesDirPath));
      assert(p.isWithin(tempDir, packagesDirPath));

      packagesLink.deleteSync();

      var firstExtraFile = true;
      var initialFiles = new Directory(contentPath)
          .listSync(recursive: true, followLinks: false);
      // TODO: use whereType when github.com/dart-lang/sdk/issues/32463 is fixed
      for (var file in initialFiles.where((i) => i is File)) {
        var relativePath = p.relative(file.path, from: contentPath);

        if (_badFileGlob.matches(relativePath)) {
          if (firstExtraFile) {
            print('Deleting extra files from output directory:');
            firstExtraFile = false;
          }
          file.deleteSync();
          print('  $relativePath');
        }
      }

      var packagesDir = new Directory(packagesDirPath);

      print('Populating contents...');

      var excludeCount = 0;
      await for (var item in packagesDir.list(recursive: true)) {
        if (item is File) {
          var relativePath = p.relative(item.path, from: tempDir);

          if (_badFileGlob.matches(relativePath)) {
            excludeCount++;
            continue;
          }

          if (p.isWithin('packages/\$sdk', relativePath)) {
            // TODO: required for DDC build – need to detect!
            continue;
          }

          var destinationPath = p.join(contentPath, relativePath);

          if (FileSystemEntity.typeSync(p.dirname(destinationPath),
                  followLinks: false) ==
              FileSystemEntityType.NOT_FOUND) {
            await runProcess('mkdir', ['-p', p.dirname(destinationPath)]);
          }

          stdout.write('.');
          await runProcess('cp', ['-n', item.path, destinationPath]);
        }
      }
      print('');
      if (excludeCount > 0) {
        print(
            'Excluded $excludeCount item(s) matching `${_globItems.join(', ')}`.');
      }

      break;
    default:
      throw new StateError('Not sure what to do here...');
  }

  return args.join(' ');
}

final _globItems = const [
  '.packages',
  '**.dart',
  '**.module',
  '**.dart.js.deps',
  '**.dart.js.tar.gz',
  '**.ng_placeholder' // Generated by pkg:angular
];

final _badFileGlob = new Glob('{${_globItems.join(',')}}');
